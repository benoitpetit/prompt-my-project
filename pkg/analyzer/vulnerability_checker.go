package analyzer

import (
	"encoding/json"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

// VulnerabilityLevel represents the severity of a vulnerability
type VulnerabilityLevel string

const (
	VulnCritical VulnerabilityLevel = "critical"
	VulnHigh     VulnerabilityLevel = "high"
	VulnMedium   VulnerabilityLevel = "medium"
	VulnLow      VulnerabilityLevel = "low"
	VulnInfo     VulnerabilityLevel = "info"
)

// Vulnerability represents a detected security vulnerability
type Vulnerability struct {
	PackageName    string             `json:"package_name"`
	Version        string             `json:"version"`
	Severity       VulnerabilityLevel `json:"severity"`
	CVEID          string             `json:"cve_id,omitempty"`
	Description    string             `json:"description"`
	Recommendation string             `json:"recommendation"`
	DetectedAt     time.Time          `json:"detected_at"`
}

// OutdatedDependency represents a package that has newer versions available
type OutdatedDependency struct {
	PackageName    string    `json:"package_name"`
	CurrentVersion string    `json:"current_version"`
	LatestVersion  string    `json:"latest_version"`
	VersionsBehind int       `json:"versions_behind"`
	UpdatedAt      time.Time `json:"updated_at"`
	Breaking       bool      `json:"breaking"` // true if update involves breaking changes
}

// VulnerabilityChecker checks dependencies for vulnerabilities and outdated packages
type VulnerabilityChecker struct {
	rootDir            string
	knownVulns         map[string][]Vulnerability
	deprecatedPackages map[string]string
}

// NewVulnerabilityChecker creates a new vulnerability checker
func NewVulnerabilityChecker(rootDir string) *VulnerabilityChecker {
	return &VulnerabilityChecker{
		rootDir:            rootDir,
		knownVulns:         loadKnownVulnerabilities(),
		deprecatedPackages: loadDeprecatedPackages(),
	}
}

// CheckDependencies checks all dependencies for vulnerabilities and outdated versions
func (vc *VulnerabilityChecker) CheckDependencies(analysis *DependencyAnalysis) ([]Vulnerability, []OutdatedDependency) {
	vulnerabilities := []Vulnerability{}
	outdated := []OutdatedDependency{}

	if analysis == nil {
		return vulnerabilities, outdated
	}

	for _, dep := range analysis.Dependencies {
		// Check for known vulnerabilities
		if vulns := vc.checkVulnerability(dep); len(vulns) > 0 {
			vulnerabilities = append(vulnerabilities, vulns...)
		}

		// Check if deprecated
		if reason, isDeprecated := vc.deprecatedPackages[dep.Name]; isDeprecated {
			vulnerabilities = append(vulnerabilities, Vulnerability{
				PackageName:    dep.Name,
				Version:        dep.Version,
				Severity:       VulnMedium,
				Description:    "Package is deprecated: " + reason,
				Recommendation: "Consider migrating to an alternative package",
				DetectedAt:     time.Now(),
			})
		}

		// Check if outdated
		if outdatedInfo := vc.checkOutdated(dep); outdatedInfo != nil {
			outdated = append(outdated, *outdatedInfo)
		}
	}

	return vulnerabilities, outdated
}

// checkVulnerability checks a single dependency for known vulnerabilities
func (vc *VulnerabilityChecker) checkVulnerability(dep Dependency) []Vulnerability {
	vulns := []Vulnerability{}

	// Check against known vulnerabilities database
	if knownVulns, exists := vc.knownVulns[dep.Name]; exists {
		for _, vuln := range knownVulns {
			if vc.versionAffected(dep.Version, vuln.Version) {
				vulnCopy := vuln
				vulnCopy.DetectedAt = time.Now()
				vulns = append(vulns, vulnCopy)
			}
		}
	}

	// Pattern-based vulnerability detection
	vulns = append(vulns, vc.patternBasedDetection(dep)...)

	return vulns
}

// versionAffected checks if a version is affected by a vulnerability
func (vc *VulnerabilityChecker) versionAffected(installedVersion, vulnerableVersion string) bool {
	// Remove version prefixes (^, ~, >=, etc.)
	cleanInstalled := cleanVersion(installedVersion)
	cleanVulnerable := cleanVersion(vulnerableVersion)

	// Simple version comparison (simplified for this implementation)
	// In production, use proper semver comparison library
	return cleanInstalled == cleanVulnerable || strings.HasPrefix(cleanInstalled, cleanVulnerable)
}

// patternBasedDetection performs pattern-based vulnerability detection
func (vc *VulnerabilityChecker) patternBasedDetection(dep Dependency) []Vulnerability {
	vulns := []Vulnerability{}

	// Check for very old versions (likely vulnerable)
	if vc.isVeryOldVersion(dep.Version) {
		vulns = append(vulns, Vulnerability{
			PackageName:    dep.Name,
			Version:        dep.Version,
			Severity:       VulnMedium,
			Description:    "Package version is very old and may contain known vulnerabilities",
			Recommendation: "Update to the latest stable version",
			DetectedAt:     time.Now(),
		})
	}

	// Check for pre-release versions in production
	if dep.Type == ProductionDep && vc.isPreReleaseVersion(dep.Version) {
		vulns = append(vulns, Vulnerability{
			PackageName:    dep.Name,
			Version:        dep.Version,
			Severity:       VulnLow,
			Description:    "Using pre-release version in production dependencies",
			Recommendation: "Use stable release versions for production",
			DetectedAt:     time.Now(),
		})
	}

	return vulns
}

// checkOutdated checks if a dependency is outdated
func (vc *VulnerabilityChecker) checkOutdated(dep Dependency) *OutdatedDependency {
	// This is a simplified implementation
	// In production, this would query package registries (npm, crates.io, pypi, etc.)

	// For now, we detect based on version patterns
	if vc.likelyOutdated(dep.Version) {
		return &OutdatedDependency{
			PackageName:    dep.Name,
			CurrentVersion: dep.Version,
			LatestVersion:  "unknown", // Would be fetched from registry
			VersionsBehind: 0,         // Would be calculated
			UpdatedAt:      time.Now(),
			Breaking:       false,
		}
	}

	return nil
}

// isVeryOldVersion checks if a version is very old (> 3 years)
func (vc *VulnerabilityChecker) isVeryOldVersion(version string) bool {
	// Check for versions like 0.x.x or 1.x.x
	re := regexp.MustCompile(`^[~^>=<]*([0-2])\.`)
	matches := re.FindStringSubmatch(version)
	if len(matches) > 1 {
		majorVersion := matches[1]
		// Major version 0 or 1 might be old
		if majorVersion == "0" {
			return true
		}
	}
	return false
}

// isPreReleaseVersion checks if a version is pre-release
func (vc *VulnerabilityChecker) isPreReleaseVersion(version string) bool {
	preReleaseIndicators := []string{
		"alpha", "beta", "rc", "pre", "preview", "canary", "next", "dev",
	}

	versionLower := strings.ToLower(version)
	for _, indicator := range preReleaseIndicators {
		if strings.Contains(versionLower, indicator) {
			return true
		}
	}
	return false
}

// likelyOutdated checks if a version is likely outdated based on patterns
func (vc *VulnerabilityChecker) likelyOutdated(version string) bool {
	// Very conservative check - only flag obviously old versions
	cleanVer := cleanVersion(version)

	// Versions starting with 0.0.x are likely outdated
	if strings.HasPrefix(cleanVer, "0.0.") {
		return true
	}

	return false
}

// cleanVersion removes version prefixes
func cleanVersion(version string) string {
	// Remove common prefixes
	version = strings.TrimPrefix(version, "^")
	version = strings.TrimPrefix(version, "~")
	version = strings.TrimPrefix(version, ">=")
	version = strings.TrimPrefix(version, "<=")
	version = strings.TrimPrefix(version, ">")
	version = strings.TrimPrefix(version, "<")
	version = strings.TrimPrefix(version, "=")
	version = strings.TrimPrefix(version, "v")
	return strings.TrimSpace(version)
}

// loadKnownVulnerabilities loads a database of known vulnerabilities
func loadKnownVulnerabilities() map[string][]Vulnerability {
	// In production, this would load from a CVE database or API
	// For now, we maintain a small list of well-known vulnerable packages

	vulnDB := make(map[string][]Vulnerability)

	// Example: Node.js known vulnerabilities
	vulnDB["lodash"] = []Vulnerability{
		{
			Version:        "4.17.15",
			Severity:       VulnHigh,
			CVEID:          "CVE-2019-10744",
			Description:    "Prototype pollution vulnerability",
			Recommendation: "Update to lodash@4.17.21 or later",
		},
	}

	vulnDB["axios"] = []Vulnerability{
		{
			Version:        "0.21.0",
			Severity:       VulnMedium,
			CVEID:          "CVE-2020-28168",
			Description:    "SSRF vulnerability in axios",
			Recommendation: "Update to axios@0.21.1 or later",
		},
	}

	vulnDB["express"] = []Vulnerability{
		{
			Version:        "4.17.0",
			Severity:       VulnMedium,
			CVEID:          "CVE-2022-24999",
			Description:    "Open redirect vulnerability",
			Recommendation: "Update to express@4.17.3 or later",
		},
	}

	// Python known vulnerabilities
	vulnDB["django"] = []Vulnerability{
		{
			Version:        "2.2.0",
			Severity:       VulnHigh,
			CVEID:          "CVE-2021-35042",
			Description:    "SQL injection vulnerability",
			Recommendation: "Update to Django 2.2.24 or later",
		},
	}

	vulnDB["flask"] = []Vulnerability{
		{
			Version:        "0.12.0",
			Severity:       VulnMedium,
			CVEID:          "CVE-2018-1000656",
			Description:    "Denial of service vulnerability",
			Recommendation: "Update to Flask 1.0 or later",
		},
	}

	vulnDB["requests"] = []Vulnerability{
		{
			Version:        "2.19.0",
			Severity:       VulnHigh,
			CVEID:          "CVE-2018-18074",
			Description:    "Credential exposure vulnerability",
			Recommendation: "Update to requests 2.20.0 or later",
		},
	}

	// Load from external file if available
	vulnFile := filepath.Join(os.TempDir(), "pmp_vulnerabilities.json")
	if data, err := os.ReadFile(vulnFile); err == nil {
		var externalVulns map[string][]Vulnerability
		if json.Unmarshal(data, &externalVulns) == nil {
			// Merge with existing
			for pkg, vulns := range externalVulns {
				vulnDB[pkg] = append(vulnDB[pkg], vulns...)
			}
		}
	}

	return vulnDB
}

// loadDeprecatedPackages loads a list of deprecated packages
func loadDeprecatedPackages() map[string]string {
	deprecated := make(map[string]string)

	// Node.js deprecated packages
	deprecated["request"] = "Package deprecated, use axios or node-fetch instead"
	deprecated["gulp-util"] = "Package deprecated, use individual utilities"
	deprecated["node-uuid"] = "Use uuid package instead"
	deprecated["babel-preset-es2015"] = "Use @babel/preset-env instead"
	deprecated["babel-preset-stage-0"] = "Use explicit plugin list instead"

	// Python deprecated packages
	deprecated["optparse"] = "Use argparse instead (built-in)"
	deprecated["imp"] = "Use importlib instead"

	return deprecated
}

// GetVulnerabilitySummary returns a human-readable summary of vulnerabilities
func GetVulnerabilitySummary(vulnerabilities []Vulnerability, outdated []OutdatedDependency) string {
	var sb strings.Builder

	sb.WriteString("Security & Dependency Health Report:\n")
	sb.WriteString("====================================\n\n")

	if len(vulnerabilities) == 0 && len(outdated) == 0 {
		sb.WriteString("âœ… No known vulnerabilities or outdated packages detected.\n")
		return sb.String()
	}

	if len(vulnerabilities) > 0 {
		sb.WriteString("âš ï¸  Vulnerabilities Detected: ")
		sb.WriteString(intToString(len(vulnerabilities)))
		sb.WriteString("\n\n")

		// Count by severity
		severityCounts := make(map[VulnerabilityLevel]int)
		for _, vuln := range vulnerabilities {
			severityCounts[vuln.Severity]++
		}

		if count, ok := severityCounts[VulnCritical]; ok && count > 0 {
			sb.WriteString("  ðŸ”´ Critical: ")
			sb.WriteString(intToString(count))
			sb.WriteString("\n")
		}
		if count, ok := severityCounts[VulnHigh]; ok && count > 0 {
			sb.WriteString("  ðŸŸ  High: ")
			sb.WriteString(intToString(count))
			sb.WriteString("\n")
		}
		if count, ok := severityCounts[VulnMedium]; ok && count > 0 {
			sb.WriteString("  ðŸŸ¡ Medium: ")
			sb.WriteString(intToString(count))
			sb.WriteString("\n")
		}
		if count, ok := severityCounts[VulnLow]; ok && count > 0 {
			sb.WriteString("  ðŸŸ¢ Low: ")
			sb.WriteString(intToString(count))
			sb.WriteString("\n")
		}

		sb.WriteString("\nTop Vulnerabilities:\n")
		// Show up to 5 most severe
		shown := 0
		for _, severity := range []VulnerabilityLevel{VulnCritical, VulnHigh, VulnMedium, VulnLow} {
			for _, vuln := range vulnerabilities {
				if vuln.Severity == severity && shown < 5 {
					sb.WriteString("\n  â€¢ ")
					sb.WriteString(vuln.PackageName)
					sb.WriteString("@")
					sb.WriteString(vuln.Version)
					sb.WriteString(" [")
					sb.WriteString(string(vuln.Severity))
					sb.WriteString("]\n")
					sb.WriteString("    ")
					sb.WriteString(vuln.Description)
					sb.WriteString("\n")
					if vuln.CVEID != "" {
						sb.WriteString("    CVE: ")
						sb.WriteString(vuln.CVEID)
						sb.WriteString("\n")
					}
					sb.WriteString("    Fix: ")
					sb.WriteString(vuln.Recommendation)
					sb.WriteString("\n")
					shown++
				}
			}
		}
	}

	if len(outdated) > 0 {
		sb.WriteString("\nðŸ“¦ Outdated Packages: ")
		sb.WriteString(intToString(len(outdated)))
		sb.WriteString("\n\n")

		for i, pkg := range outdated {
			if i >= 5 { // Show only first 5
				sb.WriteString("  ... and ")
				sb.WriteString(intToString(len(outdated) - 5))
				sb.WriteString(" more\n")
				break
			}
			sb.WriteString("  â€¢ ")
			sb.WriteString(pkg.PackageName)
			sb.WriteString(": ")
			sb.WriteString(pkg.CurrentVersion)
			if pkg.LatestVersion != "unknown" {
				sb.WriteString(" â†’ ")
				sb.WriteString(pkg.LatestVersion)
			}
			if pkg.Breaking {
				sb.WriteString(" (breaking changes)")
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// SaveVulnerabilityReport saves vulnerability report to a file
func SaveVulnerabilityReport(outputDir string, vulnerabilities []Vulnerability, outdated []OutdatedDependency) error {
	report := struct {
		GeneratedAt      time.Time            `json:"generated_at"`
		Vulnerabilities  []Vulnerability      `json:"vulnerabilities"`
		OutdatedPackages []OutdatedDependency `json:"outdated_packages"`
		Summary          struct {
			TotalVulnerabilities int `json:"total_vulnerabilities"`
			Critical             int `json:"critical"`
			High                 int `json:"high"`
			Medium               int `json:"medium"`
			Low                  int `json:"low"`
			TotalOutdated        int `json:"total_outdated"`
		} `json:"summary"`
	}{
		GeneratedAt:      time.Now(),
		Vulnerabilities:  vulnerabilities,
		OutdatedPackages: outdated,
	}

	// Calculate summary
	report.Summary.TotalVulnerabilities = len(vulnerabilities)
	report.Summary.TotalOutdated = len(outdated)

	for _, vuln := range vulnerabilities {
		switch vuln.Severity {
		case VulnCritical:
			report.Summary.Critical++
		case VulnHigh:
			report.Summary.High++
		case VulnMedium:
			report.Summary.Medium++
		case VulnLow:
			report.Summary.Low++
		}
	}

	// Create output directory if needed
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	// Write JSON report
	reportPath := filepath.Join(outputDir, "security_report.json")
	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(reportPath, data, 0644)
}
